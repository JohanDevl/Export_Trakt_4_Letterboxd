#!/bin/bash
set -e

# Improved logging function
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    
    case "$level" in
        "INFO")  echo -e "â„¹ï¸ [INFO] $timestamp - $message" ;;
        "WARN")  echo -e "âš ï¸ [WARNING] $timestamp - $message" ;;
        "ERROR") echo -e "âŒ [ERROR] $timestamp - $message" ;;
        "DEBUG") echo -e "ðŸ” [DEBUG] $timestamp - $message" ;;
        "SUCCESS") echo -e "âœ… [SUCCESS] $timestamp - $message" ;;
    esac
}

# Debug function for file and directory information
debug_file_info() {
    local path="$1"
    local type="$2"
    
    if [ -e "$path" ]; then
        log_message "DEBUG" "$type exists: $path"
        if [ -d "$path" ]; then
            log_message "DEBUG" "Directory permissions: $(stat -c '%a %n' "$path" 2>/dev/null || ls -la "$path" | head -n 1)"
            log_message "DEBUG" "Owner/Group: $(stat -c '%U:%G' "$path" 2>/dev/null || ls -la "$path" | head -n 1 | awk '{print $3":"$4}')"
            log_message "DEBUG" "Content count: $(ls -la "$path" | wc -l) items"
        elif [ -f "$path" ]; then
            log_message "DEBUG" "File permissions: $(stat -c '%a %n' "$path" 2>/dev/null || ls -la "$path" | head -n 1)"
            log_message "DEBUG" "Owner/Group: $(stat -c '%U:%G' "$path" 2>/dev/null || ls -la "$path" | head -n 1 | awk '{print $3":"$4}')"
            log_message "DEBUG" "File size: $(stat -c '%s' "$path" 2>/dev/null || ls -la "$path" | awk '{print $5}') bytes"
            
            if [ -s "$path" ]; then
                log_message "DEBUG" "File has content"
            else
                log_message "WARN" "File is empty"
            fi
            
            if [ -r "$path" ]; then
                log_message "DEBUG" "File is readable"
            else
                log_message "ERROR" "File is not readable"
            fi
            
            if [ -w "$path" ]; then
                log_message "DEBUG" "File is writable"
            else
                log_message "ERROR" "File is not writable"
            fi
        fi
    else
        log_message "ERROR" "$type does not exist: $path"
        log_message "DEBUG" "Parent directory exists: $(if [ -d "$(dirname "$path")" ]; then echo "Yes"; else echo "No"; fi)"
        if [ -d "$(dirname "$path")" ]; then
            log_message "DEBUG" "Parent directory permissions: $(stat -c '%a %n' "$(dirname "$path")" 2>/dev/null || ls -la "$(dirname "$path")" | head -n 1)"
        fi
    fi
}

# Initial system information
log_message "INFO" "Starting Docker container for Export_Trakt_4_Letterboxd"
log_message "DEBUG" "Container environment:"
log_message "DEBUG" "User: $(id)"
log_message "DEBUG" "Working directory: $(pwd)"
log_message "DEBUG" "Environment variables:"
log_message "DEBUG" "- TZ: ${TZ:-Not set}"
log_message "DEBUG" "- CRON_SCHEDULE: ${CRON_SCHEDULE:-Not set}"
log_message "DEBUG" "- EXPORT_OPTION: ${EXPORT_OPTION:-Not set}"

# Create config directory if it doesn't exist
mkdir -p /app/config

# Create example config file if it doesn't exist
if [ ! -f /app/config/.config.cfg.example ]; then
    echo "Creating example config file in config directory..."
    cat > /app/config/.config.cfg.example << 'EOF'
############################################################################
# TRAKT API CONFIGURATION
############################################################################
# API credentials - Get these from https://trakt.tv/oauth/applications
API_KEY="YOUR_API_KEY_HERE"
API_SECRET="YOUR_API_SECRET_HERE"
API_URL="https://api.trakt.tv"

# Authentication tokens - Generated by setup_trakt.sh
ACCESS_TOKEN=""
REFRESH_TOKEN=""
REDIRECT_URI="urn:ietf:wg:oauth:2.0:oob"

# User information
USERNAME="YOUR_TRAKT_USERNAME"

############################################################################
# DIRECTORY PATHS
############################################################################
# Backup and output directories
BACKUP_DIR="./backup/$(date +"%Y-%m-%d_%H-%M-%S")_trakt-backup"
DOSLOG="./logs"
DOSCOPY="./copy"
BRAIN_OPS="./brain_ops"

# Date format for filenames
DATE=$(date +%Y%m%d_%H%M)
LOG="${DOSLOG}/${DATE}-Export_Trakt.txt"

############################################################################
# DISPLAY SETTINGS
############################################################################
# Terminal colors
RED='\033[0;31m'     # Color code for error messages
GREEN='\033[0;32m'   # Color code for success messages
NC='\033[0m'         # No Color 
BOLD='\033[1m'       # Code for bold text
SAISPAS='\e[1;33;41m' # Background color code: 1;33 for yellow, 44 for red

############################################################################
# INITIALIZATION
############################################################################
# Create necessary directories if they don't exist
if [ -d ./TEMP ]; then
    rm -r ./TEMP
fi
mkdir TEMP

if [ ! -d $DOSLOG ]; then
    mkdir $DOSLOG
fi

if [ ! -d $DOSCOPY ]; then
    mkdir $DOSCOPY
fi

if [ ! -d $BRAIN_OPS ]; then
    mkdir $BRAIN_OPS
fi
EOF
    echo "Example config file created at /app/config/.config.cfg.example"
fi

# Check if config file exists
if [ ! -f /app/config/.config.cfg ]; then
    echo "Config file not found. Creating from template..."
    cp /app/config/.config.cfg.example /app/config/.config.cfg
    echo "Please edit /app/config/.config.cfg with your Trakt API credentials."
fi

# Function to verify and add missing variables to the config file
verify_config_variables() {
    local config_file="/app/config/.config.cfg"
    local example_file="/app/config/.config.cfg.example"
    local missing_vars=0
    local added_vars=0
    
    log_message "INFO" "Verifying configuration variables..."
    
    # Create a temporary file to store the list of required variables
    cat > /tmp/required_vars.txt << 'EOF'
API_KEY
API_SECRET
API_URL
ACCESS_TOKEN
REFRESH_TOKEN
REDIRECT_URI
USERNAME
BACKUP_DIR
DOSLOG
DOSCOPY
BRAIN_OPS
DATE
LOG
RED
GREEN
NC
BOLD
SAISPAS
EOF
    
    # Check each required variable
    while IFS= read -r var; do
        if ! grep -q "^${var}=" "$config_file"; then
            log_message "WARN" "Missing variable: ${var}"
            missing_vars=$((missing_vars + 1))
            
            # Extract the variable definition from the example file
            var_line=$(grep "^${var}=" "$example_file")
            
            if [ -n "$var_line" ]; then
                # Add the variable to the config file
                echo "$var_line" >> "$config_file"
                added_vars=$((added_vars + 1))
                log_message "INFO" "Added ${var} to config file"
            else
                log_message "ERROR" "Could not find ${var} in example file"
            fi
        fi
    done < /tmp/required_vars.txt
    
    # Check for initialization section
    if ! grep -q "INITIALIZATION" "$config_file"; then
        log_message "WARN" "Missing INITIALIZATION section"
        
        # Extract the initialization section from the example file
        sed -n '/INITIALIZATION/,/^fi$/p' "$example_file" > /tmp/init_section.txt
        
        # Add the initialization section to the config file
        echo "" >> "$config_file"
        echo "############################################################################" >> "$config_file"
        echo "# INITIALIZATION" >> "$config_file"
        echo "############################################################################" >> "$config_file"
        cat /tmp/init_section.txt >> "$config_file"
        
        log_message "INFO" "Added INITIALIZATION section to config file"
        added_vars=$((added_vars + 1))
    fi
    
    # Clean up temporary files
    rm -f /tmp/required_vars.txt /tmp/init_section.txt
    
    # Report results
    if [ $missing_vars -eq 0 ]; then
        log_message "SUCCESS" "All required variables are present in the config file."
    else
        if [ $added_vars -eq $missing_vars ]; then
            log_message "SUCCESS" "Added $added_vars missing variables to the config file."
        else
            log_message "WARN" "Found $missing_vars missing variables, but could only add $added_vars."
            log_message "WARN" "Please check your config file manually."
        fi
    fi
}

# Remove any existing symlink or config file in the root directory
if [ -L /app/.config.cfg ] || [ -f /app/.config.cfg ]; then
    log_message "INFO" "Removing old config file from root directory"
    rm -f /app/.config.cfg
    log_message "SUCCESS" "Removed old config file from root directory"
fi

# Create necessary directories with proper permissions
log_message "INFO" "Creating necessary directories with proper permissions"
mkdir -p /app/logs /app/copy /app/brain_ops /app/backup /app/TEMP
chmod -R 777 /app/logs /app/copy /app/brain_ops /app/backup /app/TEMP /app/config
log_message "SUCCESS" "Directories created with permissions 777"

# Debug directory information
debug_file_info "/app/logs" "Logs directory"
debug_file_info "/app/copy" "Copy directory"
debug_file_info "/app/brain_ops" "Brain ops directory"
debug_file_info "/app/backup" "Backup directory"
debug_file_info "/app/TEMP" "Temp directory"

# Ensure the config file is writable
log_message "INFO" "Setting config file permissions"
chmod 666 /app/config/.config.cfg 2>/dev/null || true
chmod 666 /app/config/.config.cfg.example 2>/dev/null || true
log_message "SUCCESS" "Config file permissions set to 666"

# Verify and add missing variables to the config file
verify_config_variables

# Make scripts executable
log_message "INFO" "Making scripts executable"
chmod +x /app/Export_Trakt_4_Letterboxd.sh /app/setup_trakt.sh
log_message "SUCCESS" "Scripts are now executable"

# Update scripts to use the config file in the config directory
log_message "INFO" "Updating scripts to use config file in the config directory"
sed -i 's|CONFIG_FILE="${SCRIPT_DIR}/.config.cfg"|CONFIG_FILE="/app/config/.config.cfg"|g' /app/setup_trakt.sh
sed -i 's|source ${SCRIPT_DIR}/.config.cfg|source /app/config/.config.cfg|g' /app/Export_Trakt_4_Letterboxd.sh
log_message "SUCCESS" "Scripts updated to use config file in the config directory"

# Modify the permission settings in the Export_Trakt_4_Letterboxd.sh script
log_message "INFO" "Updating CSV file permissions in main script"
sed -i 's|chmod 644 "${DOSCOPY}/letterboxd_import.csv"|chmod 666 "${DOSCOPY}/letterboxd_import.csv"|g' /app/Export_Trakt_4_Letterboxd.sh
log_message "SUCCESS" "Updated CSV file permissions in main script"

# Setup cron job if CRON_SCHEDULE is provided
if [ ! -z "${CRON_SCHEDULE}" ]; then
    # Install cron if not already installed
    if ! command -v cron &> /dev/null; then
        log_message "INFO" "Installing cron..."
        apk add --no-cache dcron
        log_message "SUCCESS" "Cron installed"
    else
        log_message "INFO" "Cron is already installed"
    fi

    # Set default export option if not provided
    EXPORT_OPTION=${EXPORT_OPTION:-normal}
    
    # Debug messages to help diagnose issues
    log_message "INFO" "Setting up cron job with the following parameters:"
    log_message "DEBUG" "EXPORT_OPTION = ${EXPORT_OPTION}"
    log_message "DEBUG" "CRON_SCHEDULE = ${CRON_SCHEDULE}"
    
    # Create a wrapper script for the cron job
    log_message "INFO" "Creating cron wrapper script"
    cat > /app/cron_wrapper.sh << EOF
#!/bin/bash
# Get the start time
START_TIME=$(date +"%Y-%m-%d %H:%M:%S")

# Log to container stdout with a friendly message
echo "ðŸŽ¬ [CRON] Starting Trakt to Letterboxd Export at ${START_TIME} ðŸŽ¬" > /proc/1/fd/1
echo "ðŸ“Š Exporting your Trakt data with option '${EXPORT_OPTION}'... This may take a few minutes." > /proc/1/fd/1
echo "DEBUG: Using export option: ${EXPORT_OPTION}" > /proc/1/fd/1

# Make sure directories have proper permissions
chmod -R 777 /app/logs /app/copy /app/brain_ops /app/backup
echo "Permissions set on directories: logs, copy, brain_ops, backup" > /proc/1/fd/1

# Redirect all output to the log file
exec > /app/logs/cron_export.log 2>&1

# Print friendly messages
echo "========================================================"
echo "ðŸŽ¬ Starting Trakt to Letterboxd Export - $(date)"
echo "========================================================"
echo "ðŸŒŸ Exporting your Trakt data to Letterboxd format..."
echo "ðŸ“Š Using export option: ${EXPORT_OPTION}"
echo "========================================================"

# Debug directory structure and permissions
echo "Directory permissions before export:"
ls -la /app/copy /app/logs /app/brain_ops /app/backup

# Run the export script
cd /app && ./Export_Trakt_4_Letterboxd.sh ${EXPORT_OPTION}

# Check if the script executed correctly
EXIT_CODE=$?
if [ $EXIT_CODE -eq 0 ]; then
    echo "Export script finished successfully with exit code 0"
else
    echo "WARNING: Export script exited with code $EXIT_CODE"
fi

# Check if the CSV file exists
if [ -f /app/copy/letterboxd_import.csv ]; then
    echo "CSV file exists after export"
    ls -la /app/copy/letterboxd_import.csv
    
    # Ensure the generated CSV file has the correct permissions
    chmod 666 /app/copy/letterboxd_import.csv
    echo "CSV file permissions updated to 666"
    ls -la /app/copy/letterboxd_import.csv
else
    echo "ERROR: CSV file was not created at /app/copy/letterboxd_import.csv"
    echo "Contents of copy directory:"
    ls -la /app/copy
fi

# Get the end time
END_TIME=$(date +"%Y-%m-%d %H:%M:%S")

# Print completion message
echo "========================================================"
echo "âœ… Export completed at $(date)"
echo "ðŸŽ‰ Your Letterboxd import file is ready in the copy directory!"
echo "========================================================"

# Log to container stdout with a friendly completion message
echo "âœ… [CRON] Trakt to Letterboxd Export completed at ${END_TIME} âœ…" > /proc/1/fd/1
echo "ðŸŽ‰ Your Letterboxd import file is ready in the copy directory! ðŸŽ‰" > /proc/1/fd/1
EOF
    
    # Make the wrapper script executable
    chmod +x /app/cron_wrapper.sh
    log_message "SUCCESS" "Cron wrapper script created at /app/cron_wrapper.sh"
    debug_file_info "/app/cron_wrapper.sh" "Cron wrapper script"
    
    # Create cron job using the wrapper script
    echo "${CRON_SCHEDULE} /app/cron_wrapper.sh" > /etc/crontabs/root
    log_message "SUCCESS" "Cron job schedule set: ${CRON_SCHEDULE}"
    log_message "DEBUG" "Cron content: $(cat /etc/crontabs/root)"
    
    # Make sure the log file exists and is writable
    touch /app/logs/cron_export.log
    chmod 666 /app/logs/cron_export.log
    log_message "INFO" "Created cron log file with permissions 666"
    debug_file_info "/app/logs/cron_export.log" "Cron log file"
    
    # Start cron daemon with appropriate logging
    log_message "INFO" "Starting cron daemon..."
    crond -b -L 8
    log_message "SUCCESS" "Cron daemon started in background"
    
    log_message "INFO" "Cron job has been set up. Logs will be written to /app/logs/cron_export.log"
    log_message "INFO" "You can also see cron execution messages in the container logs."
else
    log_message "INFO" "No CRON_SCHEDULE provided, skipping cron setup"
fi

# Display help message
log_message "INFO" "=== Export Trakt 4 Letterboxd ==="
echo ""
echo "Available commands:"
echo "  setup_trakt.sh - Configure Trakt API authentication"
echo "  Export_Trakt_4_Letterboxd.sh [option] - Export Trakt data"
echo ""
echo "Options for Export_Trakt_4_Letterboxd.sh:"
echo "  normal (default) - Export rated movies, episodes, history, and watchlist"
echo "  initial - Export only rated and watched movies"
echo "  complete - Export all available data"
echo ""

# Execute command if provided, otherwise keep container running
if [ $# -gt 0 ]; then
    log_message "INFO" "Executing provided command: $@"
    exec "$@"
else
    log_message "INFO" "No command provided. Container will stay alive for use with docker exec."
    log_message "INFO" "Use 'docker exec -it <container_name> bash' to connect to this container."
    
    # Final file checks before keeping container alive
    log_message "DEBUG" "Final directory and permission checks:"
    debug_file_info "/app/copy" "Copy directory"
    if [ -f "/app/copy/letterboxd_import.csv" ]; then
        debug_file_info "/app/copy/letterboxd_import.csv" "Letterboxd import CSV file"
    fi
    
    # Keep the container running
    log_message "INFO" "Container is now running in standby mode"
    tail -f /dev/null
fi 