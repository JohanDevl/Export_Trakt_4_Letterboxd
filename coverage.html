
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>export_trakt: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/JohanDevl/Export_Trakt_4_Letterboxd/cmd/export_trakt/main.go (0.0%)</option>
				
				<option value="file1">github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/api/trakt.go (75.0%)</option>
				
				<option value="file2">github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/config/config.go (85.4%)</option>
				
				<option value="file3">github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/export/letterboxd.go (84.6%)</option>
				
				<option value="file4">github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/i18n/i18n.go (86.7%)</option>
				
				<option value="file5">github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/logger/logger.go (90.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"

        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/api"
        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/config"
        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/export"
        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/i18n"
        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/logger"
)

func main() <span class="cov0" title="0">{
        // Parse command line flags
        configPath := flag.String("config", "config/config.toml", "Path to configuration file")
        flag.Parse()

        // Initialize logger
        log := logger.NewLogger()

        // Load configuration
        log.Info("startup.loading_config", map[string]interface{}{"path": *configPath})
        cfg, err := config.LoadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("errors.config_load_failed", map[string]interface{}{"error": err.Error()})
                os.Exit(1)
        }</span>

        // Configure logger based on config
        <span class="cov0" title="0">log.SetLogLevel(cfg.Logging.Level)
        if cfg.Logging.File != "" </span><span class="cov0" title="0">{
                if err := log.SetLogFile(cfg.Logging.File); err != nil </span><span class="cov0" title="0">{
                        log.Error("errors.log_file_failed", map[string]interface{}{"error": err.Error()})
                        os.Exit(1)
                }</span>
        }

        // Initialize translator
        <span class="cov0" title="0">translator, err := i18n.NewTranslator(&amp;cfg.I18n, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("errors.translator_failed", map[string]interface{}{"error": err.Error()})
                os.Exit(1)
        }</span>

        // Update logger to use translator
        <span class="cov0" title="0">log.SetTranslator(translator)

        log.Info("startup.starting", nil)
        log.Info("startup.config_loaded", nil)

        // Initialize Trakt client
        traktClient := api.NewClient(cfg, log)

        // Get watched movies
        log.Info("export.retrieving_movies", nil)
        movies, err := traktClient.GetWatchedMovies()
        if err != nil </span><span class="cov0" title="0">{
                log.Error("errors.api_request_failed", map[string]interface{}{"error": err.Error()})
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">log.Info("export.movies_retrieved", map[string]interface{}{"count": len(movies)})

        // Initialize Letterboxd exporter
        letterboxdExporter := export.NewLetterboxdExporter(cfg, log)

        // Export movies
        log.Info("export.exporting_movies", nil)
        if err := letterboxdExporter.ExportMovies(movies); err != nil </span><span class="cov0" title="0">{
                log.Error("export.export_failed", map[string]interface{}{"error": err.Error()})
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println(translator.Translate("app.description", nil))</span>
} </pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/config"
        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/logger"
)

const (
        maxRetries    = 3
        retryInterval = time.Second
)

// MovieIDs represents the various IDs associated with a movie
type MovieIDs struct {
        Trakt int    `json:"trakt"`
        TMDB  int    `json:"tmdb"`
        IMDB  string `json:"imdb"`
        Slug  string `json:"slug"`
}

// MovieInfo represents the basic movie information
type MovieInfo struct {
        Title string   `json:"title"`
        Year  int     `json:"year"`
        IDs   MovieIDs `json:"ids"`
}

// Movie represents a watched movie with its metadata
type Movie struct {
        Movie         MovieInfo `json:"movie"`
        LastWatchedAt string    `json:"last_watched_at"`
}

// Client represents a Trakt API client
type Client struct {
        config     *config.Config
        logger     logger.Logger
        httpClient *http.Client
}

// NewClient creates a new Trakt API client
func NewClient(cfg *config.Config, log logger.Logger) *Client <span class="cov8" title="1">{
        return &amp;Client{
                config: cfg,
                logger: log,
                httpClient: &amp;http.Client{
                        Timeout: time.Second * 30,
                },
        }
}</span>

// makeRequest makes an HTTP request with retries
func (c *Client) makeRequest(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        var lastErr error
        for attempt := 0; attempt &lt; maxRetries; attempt++ </span><span class="cov8" title="1">{
                if attempt &gt; 0 </span><span class="cov8" title="1">{
                        c.logger.Warn("api.retrying_request", map[string]interface{}{
                                "attempt": attempt + 1,
                                "max":     maxRetries,
                        })
                        time.Sleep(retryInterval * time.Duration(attempt))
                }</span>

                <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("request failed: %w", err)
                        continue</span>
                }

                // Only retry on server errors (5xx)
                <span class="cov8" title="1">if resp.StatusCode &gt;= 500 </span><span class="cov8" title="1">{
                        resp.Body.Close()
                        lastErr = fmt.Errorf("server error: %d", resp.StatusCode)
                        continue</span>
                }

                <span class="cov8" title="1">return resp, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("max retries exceeded: %w", lastErr)</span>
}

// GetWatchedMovies retrieves the list of watched movies from Trakt
func (c *Client) GetWatchedMovies() ([]Movie, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("GET", c.config.Trakt.APIBaseURL+"/sync/watched/movies", nil)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("errors.api_request_failed", map[string]interface{}{
                        "error": err.Error(),
                })
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add required headers
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("trakt-api-version", "2")
        req.Header.Set("trakt-api-key", c.config.Trakt.ClientID)
        req.Header.Set("Authorization", "Bearer "+c.config.Trakt.AccessToken)

        resp, err := c.makeRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("errors.api_request_failed", map[string]interface{}{
                        "error": err.Error(),
                })
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Handle rate limiting
        if limit := resp.Header.Get("X-Ratelimit-Remaining"); limit != "" </span><span class="cov8" title="1">{
                remaining, _ := strconv.Atoi(limit)
                if remaining &lt; 100 </span><span class="cov0" title="0">{
                        c.logger.Warn("api.rate_limit_warning", map[string]interface{}{
                                "remaining": remaining,
                        })
                }</span>
        }

        // Check response status
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                var errorResp map[string]string
                if err := json.NewDecoder(resp.Body).Decode(&amp;errorResp); err != nil </span><span class="cov0" title="0">{
                        errorResp = map[string]string{"error": "unknown error"}
                }</span>
                <span class="cov8" title="1">c.logger.Error("errors.api_request_failed", map[string]interface{}{
                        "status": resp.StatusCode,
                        "error":  errorResp["error"],
                })
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, errorResp["error"])</span>
        }

        // Parse response
        <span class="cov8" title="1">var movies []Movie
        if err := json.NewDecoder(resp.Body).Decode(&amp;movies); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("errors.api_response_parse_failed", map[string]interface{}{
                        "error": err.Error(),
                })
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov8" title="1">return movies, nil</span>
} </pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "github.com/BurntSushi/toml"
)

// Config holds all configuration settings
type Config struct {
        Trakt     TraktConfig     `toml:"trakt"`
        Letterboxd LetterboxdConfig `toml:"letterboxd"`
        Export    ExportConfig    `toml:"export"`
        Logging   LoggingConfig   `toml:"logging"`
        I18n      I18nConfig      `toml:"i18n"`
}

// TraktConfig holds Trakt.tv API configuration
type TraktConfig struct {
        ClientID     string `toml:"client_id"`
        ClientSecret string `toml:"client_secret"`
        AccessToken  string `toml:"access_token"`
        APIBaseURL   string `toml:"api_base_url"`
}

// LetterboxdConfig holds Letterboxd export configuration
type LetterboxdConfig struct {
        ExportDir string `toml:"export_dir"`
}

// ExportConfig holds export settings
type ExportConfig struct {
        Format     string `toml:"format"`
        DateFormat string `toml:"date_format"`
}

// LoggingConfig holds logging settings
type LoggingConfig struct {
        Level string `toml:"level"`
        File  string `toml:"file"`
}

// I18nConfig holds internationalization settings
type I18nConfig struct {
        DefaultLanguage string `toml:"default_language"`
        Language       string `toml:"language"`
        LocalesDir    string `toml:"locales_dir"`
}

// LoadConfig reads the config file and returns a Config struct
func LoadConfig(path string) (*Config, error) <span class="cov8" title="1">{
        var config Config
        if _, err := toml.DecodeFile(path, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decode config file: %w", err)
        }</span>

        <span class="cov8" title="1">if err := config.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// Validate checks if the configuration is valid
func (c *Config) Validate() error <span class="cov8" title="1">{
        if err := c.Trakt.Validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("trakt config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := c.Letterboxd.Validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("letterboxd config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := c.Export.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("export config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := c.Logging.Validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("logging config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := c.I18n.Validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("i18n config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Validate checks if the Trakt configuration is valid
func (c *TraktConfig) Validate() error <span class="cov8" title="1">{
        if c.APIBaseURL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("api_base_url is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate checks if the Letterboxd configuration is valid
func (c *LetterboxdConfig) Validate() error <span class="cov8" title="1">{
        if c.ExportDir == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("export_dir is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate checks if the Export configuration is valid
func (c *ExportConfig) Validate() error <span class="cov8" title="1">{
        if c.Format == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("format is required")
        }</span>
        <span class="cov8" title="1">if c.DateFormat == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("date_format is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate checks if the Logging configuration is valid
func (c *LoggingConfig) Validate() error <span class="cov8" title="1">{
        if c.Level == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("level is required")
        }</span>
        <span class="cov8" title="1">validLevels := map[string]bool{
                "debug": true,
                "info":  true,
                "warn":  true,
                "error": true,
        }
        if !validLevels[c.Level] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid log level: %s", c.Level)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate checks if the I18n configuration is valid
func (c *I18nConfig) Validate() error <span class="cov8" title="1">{
        if c.DefaultLanguage == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("default_language is required")
        }</span>
        <span class="cov8" title="1">if c.Language == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("language is required")
        }</span>
        <span class="cov8" title="1">if c.LocalesDir == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("locales_dir is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
} </pre>
		
		<pre class="file" id="file3" style="display: none">package export

import (
        "encoding/csv"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "time"

        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/api"
        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/config"
        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/logger"
)

// LetterboxdExporter handles the export of movies to Letterboxd format
type LetterboxdExporter struct {
        config *config.Config
        log    logger.Logger
}

// NewLetterboxdExporter creates a new Letterboxd exporter
func NewLetterboxdExporter(cfg *config.Config, log logger.Logger) *LetterboxdExporter <span class="cov8" title="1">{
        return &amp;LetterboxdExporter{
                config: cfg,
                log:    log,
        }
}</span>

// ExportMovies exports the given movies to a CSV file in Letterboxd format
func (e *LetterboxdExporter) ExportMovies(movies []api.Movie) error <span class="cov8" title="1">{
        if err := os.MkdirAll(e.config.Letterboxd.ExportDir, 0755); err != nil </span><span class="cov8" title="1">{
                e.log.Error("errors.export_dir_create_failed", map[string]interface{}{
                        "error": err.Error(),
                })
                return fmt.Errorf("failed to create export directory: %w", err)
        }</span>

        <span class="cov8" title="1">filename := fmt.Sprintf("letterboxd-export-%s.csv", time.Now().Format("2006-01-02"))
        filePath := filepath.Join(e.config.Letterboxd.ExportDir, filename)

        file, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                e.log.Error("errors.file_create_failed", map[string]interface{}{
                        "error": err.Error(),
                })
                return fmt.Errorf("failed to create export file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        writer := csv.NewWriter(file)
        defer writer.Flush()

        // Write header
        header := []string{"Title", "Year", "WatchedDate", "Rating", "IMDb ID"}
        if err := writer.Write(header); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write header: %w", err)
        }</span>

        // Write movies
        <span class="cov8" title="1">for _, movie := range movies </span><span class="cov8" title="1">{
                // Parse watched date
                watchedDate := ""
                if movie.LastWatchedAt != "" </span><span class="cov8" title="1">{
                        if parsedTime, err := time.Parse(time.RFC3339, movie.LastWatchedAt); err == nil </span><span class="cov8" title="1">{
                                watchedDate = parsedTime.Format(e.config.Export.DateFormat)
                        }</span>
                }

                <span class="cov8" title="1">record := []string{
                        movie.Movie.Title,
                        strconv.Itoa(movie.Movie.Year),
                        watchedDate,
                        "", // Rating not available in the current API response
                        movie.Movie.IDs.IMDB,
                }

                if err := writer.Write(record); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write movie record: %w", err)
                }</span>
        }

        <span class="cov8" title="1">e.log.Info("export.export_complete", map[string]interface{}{
                "count": len(movies),
                "path":  filePath,
        })
        return nil</span>
} </pre>
		
		<pre class="file" id="file4" style="display: none">package i18n

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/config"
        "github.com/JohanDevl/Export_Trakt_4_Letterboxd/pkg/logger"
        "github.com/nicksnyder/go-i18n/v2/i18n"
        "golang.org/x/text/language"
)

// Translator handles all internationalization operations
type Translator struct {
        bundle    *i18n.Bundle
        config    *config.I18nConfig
        log       logger.Logger
        localizer *i18n.Localizer
}

// NewTranslator creates a new translator instance
func NewTranslator(cfg *config.I18nConfig, log logger.Logger) (*Translator, error) <span class="cov8" title="1">{
        bundle := i18n.NewBundle(language.English)
        bundle.RegisterUnmarshalFunc("json", json.Unmarshal)

        t := &amp;Translator{
                bundle: bundle,
                config: cfg,
                log:    log,
        }

        if err := t.loadTranslations(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">t.localizer = i18n.NewLocalizer(bundle, cfg.Language, cfg.DefaultLanguage)
        return t, nil</span>
}

// loadTranslations loads all translation files from the locales directory
func (t *Translator) loadTranslations() error <span class="cov8" title="1">{
        entries, err := os.ReadDir(t.config.LocalesDir)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read locales directory: %w", err)
        }</span>

        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if filepath.Ext(entry.Name()) != ".json" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">path := filepath.Join(t.config.LocalesDir, entry.Name())
                if _, err := t.bundle.LoadMessageFile(path); err != nil </span><span class="cov0" title="0">{
                        t.log.Warn("errors.translation_file_load_failed", map[string]interface{}{
                                "path":  path,
                                "error": err.Error(),
                        })
                        continue</span>
                }

                <span class="cov8" title="1">t.log.Debug("i18n.translation_file_loaded", map[string]interface{}{
                        "path": path,
                })</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Translate returns the translated message for the given message ID
func (t *Translator) Translate(messageID string, templateData map[string]interface{}) string <span class="cov8" title="1">{
        msg := i18n.Message{
                ID: messageID,
        }

        translation, err := t.localizer.Localize(&amp;i18n.LocalizeConfig{
                DefaultMessage: &amp;msg,
                TemplateData:   templateData,
        })

        if err != nil </span><span class="cov8" title="1">{
                t.log.Warn("errors.translation_failed", map[string]interface{}{
                        "messageID": messageID,
                        "error":     err.Error(),
                })
                return messageID
        }</span>

        <span class="cov8" title="1">return translation</span>
}

// SetLanguage changes the current language
func (t *Translator) SetLanguage(lang string) <span class="cov8" title="1">{
        t.localizer = i18n.NewLocalizer(t.bundle, lang, t.config.DefaultLanguage)
        t.config.Language = lang
        t.log.Info("i18n.language_changed", map[string]interface{}{
                "language": lang,
        })
}</span> </pre>
		
		<pre class="file" id="file5" style="display: none">package logger

import (
        "os"

        "github.com/sirupsen/logrus"
)

// Translator interface for i18n support
type Translator interface {
        Translate(messageID string, templateData map[string]interface{}) string
}

// Logger interface defines the logging methods
type Logger interface {
        Info(messageID string, data ...map[string]interface{})
        Infof(messageID string, data map[string]interface{})
        Error(messageID string, data ...map[string]interface{})
        Errorf(messageID string, data map[string]interface{})
        Warn(messageID string, data ...map[string]interface{})
        Warnf(messageID string, data map[string]interface{})
        Debug(messageID string, data ...map[string]interface{})
        Debugf(messageID string, data map[string]interface{})
        SetLogLevel(level string)
        SetLogFile(path string) error
        SetTranslator(t Translator)
}

// StandardLogger wraps logrus.Logger
type StandardLogger struct {
        *logrus.Logger
        translator Translator
}

// NewLogger creates a new logger instance
func NewLogger() Logger <span class="cov8" title="1">{
        log := logrus.New()
        log.SetOutput(os.Stdout)
        log.SetFormatter(&amp;logrus.TextFormatter{
                FullTimestamp: true,
        })
        log.SetLevel(logrus.InfoLevel)

        return &amp;StandardLogger{
                Logger: log,
        }
}</span>

// SetTranslator sets the translator for the logger
func (l *StandardLogger) SetTranslator(t Translator) <span class="cov8" title="1">{
        l.translator = t
}</span>

// translate handles message translation if a translator is available
func (l *StandardLogger) translate(messageID string, data map[string]interface{}) string <span class="cov8" title="1">{
        if l.translator != nil </span><span class="cov8" title="1">{
                return l.translator.Translate(messageID, data)
        }</span>
        <span class="cov8" title="1">return messageID</span>
}

// Info logs an info level message with translation
func (l *StandardLogger) Info(messageID string, data ...map[string]interface{}) <span class="cov8" title="1">{
        var templateData map[string]interface{}
        if len(data) &gt; 0 </span><span class="cov8" title="1">{
                templateData = data[0]
        }</span>
        <span class="cov8" title="1">l.Logger.Info(l.translate(messageID, templateData))</span>
}

// Infof logs a formatted info level message with translation
func (l *StandardLogger) Infof(messageID string, data map[string]interface{}) <span class="cov0" title="0">{
        l.Logger.Info(l.translate(messageID, data))
}</span>

// Error logs an error level message with translation
func (l *StandardLogger) Error(messageID string, data ...map[string]interface{}) <span class="cov8" title="1">{
        var templateData map[string]interface{}
        if len(data) &gt; 0 </span><span class="cov8" title="1">{
                templateData = data[0]
        }</span>
        <span class="cov8" title="1">l.Logger.Error(l.translate(messageID, templateData))</span>
}

// Errorf logs a formatted error level message with translation
func (l *StandardLogger) Errorf(messageID string, data map[string]interface{}) <span class="cov0" title="0">{
        l.Logger.Error(l.translate(messageID, data))
}</span>

// Warn logs a warning level message with translation
func (l *StandardLogger) Warn(messageID string, data ...map[string]interface{}) <span class="cov8" title="1">{
        var templateData map[string]interface{}
        if len(data) &gt; 0 </span><span class="cov8" title="1">{
                templateData = data[0]
        }</span>
        <span class="cov8" title="1">l.Logger.Warn(l.translate(messageID, templateData))</span>
}

// Warnf logs a formatted warning level message with translation
func (l *StandardLogger) Warnf(messageID string, data map[string]interface{}) <span class="cov0" title="0">{
        l.Logger.Warn(l.translate(messageID, data))
}</span>

// Debug logs a debug level message with translation
func (l *StandardLogger) Debug(messageID string, data ...map[string]interface{}) <span class="cov8" title="1">{
        var templateData map[string]interface{}
        if len(data) &gt; 0 </span><span class="cov8" title="1">{
                templateData = data[0]
        }</span>
        <span class="cov8" title="1">l.Logger.Debug(l.translate(messageID, templateData))</span>
}

// Debugf logs a formatted debug level message with translation
func (l *StandardLogger) Debugf(messageID string, data map[string]interface{}) <span class="cov0" title="0">{
        l.Logger.Debug(l.translate(messageID, data))
}</span>

// SetLogLevel sets the logging level
func (l *StandardLogger) SetLogLevel(level string) <span class="cov8" title="1">{
        switch level </span>{
        case "debug":<span class="cov8" title="1">
                l.SetLevel(logrus.DebugLevel)</span>
        case "info":<span class="cov8" title="1">
                l.SetLevel(logrus.InfoLevel)</span>
        case "warn":<span class="cov8" title="1">
                l.SetLevel(logrus.WarnLevel)</span>
        case "error":<span class="cov8" title="1">
                l.SetLevel(logrus.ErrorLevel)</span>
        default:<span class="cov8" title="1">
                l.SetLevel(logrus.InfoLevel)</span>
        }
}

// SetLogFile sets the output to a file
func (l *StandardLogger) SetLogFile(path string) error <span class="cov8" title="1">{
        file, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">l.SetOutput(file)
        return nil</span>
} </pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
